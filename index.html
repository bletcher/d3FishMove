

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Fish movements</title>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  </head>
  <body>

  <script>

    function color(d) { return d.id; }

    var colorScale = d3.scale.category10();

    var svg = d3.select("body")
      .append("svg")
      .attr("width",  600)
      .attr("height", 500);

 //  functions //     

    function keyID(d){ return d.id; }
    
    function type(d){
      d.sample = +d.sample;
      d.id = +d.id;
      d.section = +d.section;
      d.length = +d.length;
      return d;
    }

    function getData(d,s) {
      return d.filter( function(d){
        return d.sample == s;
      });
    }   
       
    // Positions the dots based on data
    function position(dot) {
      dot
        .attr("cx", function (d,i){ return i*5+10; })//{ return xScale(x(d)); })
        .attr("cy", function (d  ){ return d.section*20; })//{ return yScale(y(d)); });
        .attr("r", function(d) { return d.length; });
    }

    // Sort numbers ascending
    function compareNumbers(a, b) {
     return a - b;
    }

    // Update Individual Locations
    function updateRender(inData) {

      // JDW: if you look in the console, you'll see an error: "circles.exit"
      //      is not a function, because you've assigned the variable "circles"
      //      to the result of the enter().append() calls, so "circles" is a
      //      reference to all the circles added in this iteration
      //
      //      so that's why exit isn't working, because it doesn't exist as a
      //      method on "circles"
      //
      //      instead, "circles" should be assigned to the result of the data
      //      binding, then .enter() should be called in a separate statement

      // OLD CODE:
      // var circles = svg.selectAll("circles")
      //       .data(inData, keyID)
      //       .enter()
      //       .append("circle");

      // NEW CODE:
      // var circles = svg.selectAll("circles")
      //       .data(inData, keyID);
      // circles.enter()
      //       .append("circle");

      // JDW: but that still won't work because you're not doing the
      //      selection correctly
      //
      //      although selectAll("circles") sounds like it should work,
      //      what is "circles" referring to here?
      //
      //      what you pass to selectAll() is called a "selector" query,
      //      which is used in CSS. For example if something has class="fish",
      //      then you could select it with the selector query ".fish" because
      //      the "." means class. You can also use id's with "#",
      //      so <div id="fish"></div> could be selected with "#fish" query.
      //      Finally, you can select by tag name, which is what you want here.
      //      When you .append("circle"), that adds elements in the HTML
      //      (technically to the Document Object Model or DOM) named circle
      //      like this: <circle></circle>
      //
      //      so what you want is to selectAll("circle") which will select all
      //      elements of type "circle"
      //
      //      you were trying to select all elements of type "circles" which don't
      //      exist, so that selection always came back empty, and thus every time
      //      this was run, it would append more circles since the "circles"
      //      variable was an empty selection
      //
      //      anyway, this is what you want:

      // BIND DATA
      var circles = svg.selectAll("circle")
            .data(inData, keyID);

      // APPEND NEW CIRCLE for each data element that doesn't already have a circle
      circles.enter().append("circle")
          .style("fill",  function(d  ){ return colorScale( color(d) ); })
          .style("fill-opacity", 1e-6)
          .attr ("cx",    50)
          .attr ("cy",    200)
          .attr ("r",     function(d  ){ return d.length; })
          ;

      // UPDATE the color/position/size of each circle that has a data element
      circles
        .transition()
          .duration(1000)
            .style("fill",  function(d  ){ return colorScale( color(d) ); })
            .style("fill-opacity", 1)
            .attr ("cx",    function(d,i){ return i*10+200; })
            .attr ("cy",    function(d  ){ return d.section*30; })
            .attr ("r",     function(d  ){ return d.length; })
            ;

      // REMOVE any existing circles that no longer have data
      circles.exit()
          .transition()
            .duration(1000)
            .attr ("cx",    500)
            .attr ("cy",    200)
            .style("fill-opacity", 1e-5)
       .remove();
    }

 // run //
 
      d3.csv("d3FishMoveLong3.csv", type,  function (inData){
        //Map sample num to array
        var samps = inData.map(function(d) { return d.sample; });

        //Construct set of samples
        var sampSet = [];
        samps.forEach(function(samp) { 
          if (sampSet.indexOf(samp) == -1) {
            sampSet.push(samp);
          }
        });

        //Sort samples in ascending order
        sampSet.sort(compareNumbers)

        //Add slider to control samples
        d3.select("body")
          .append("input")
          // .attr({type: "range", name: "Sample", min: sampSet[0], max: sampSet[sampSet.length - 1], value: sampSet[sampSet.length - 1]})
          // JDW: I would set "value" of slider to first element not the last
          //      to match the updateRender(getData(inData, sampSet[0])) below
          .attr({type: "range", name: "Sample", min: sampSet[0], max: sampSet[sampSet.length - 1], value: sampSet[0]})
          .attr("id", "sampSlider")
          .property("title", "Sample: " + sampSet[sampSet.length - 1])
          .on("input", function() { 
            updateRender(getData(inData, Math.floor(this.value)));
            this.title = "Sample: " + Math.floor(this.value);
          });


        //Position first sample
        updateRender(getData(inData,sampSet[0]));

        //Move through samples     
//        sampSet.forEach(function(samp, i) {
    //      if (i > 0) {
    //        setInterval(function(){
//              updateRender(getData(inData, samp));
    //        }, 2000);
    //      };  
//        });

      });


    </script>

  </body>
</html>