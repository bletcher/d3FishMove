

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Fish movements</title>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  </head>
  <body>

  <script>
 // some global variables //
    var maxSection = 15;
    var timeSteps = 25;
    
 // set up svg element //
    var w = 800,
		    h = 550,
		    xPadding = 20,
		    yPadding = 20,
		    tweenPadding = 20;
    
    var svg = d3.select("body")
      .append("svg")
      .attr("width",  w)
      .attr("height", h);
      
    var g1 = svg.append('g');
    var g2 = svg.append('g');
      
 // Accessor functions for circle attributes
    function x(d,i) { return d.i };
    function y(d) { return d.section };
    function y2(d) { return d.distMoved};
    function r(d) { return d.river };
    
    function color(d){ return d.id; }
    function keyID(d){ return d.id; }
    function keyID2(d){ return d.id; }
      
 // Scales for absolute position.
    var xScale = d3.scale.linear().domain([50, 200]).range([xPadding, w/2-xPadding/2]),
        yScale = d3.scale.linear().domain([1, maxSection]).range([h-yPadding, yPadding]);
        
 // Scales for relative position.
    var xScale2 = d3.scale.linear().domain([50, 200]).range([w/2+xPadding, w-xPadding]),
        yScale2 = d3.scale.linear().domain([-maxSection, maxSection]).range([h-yPadding, yPadding]);

    var radiusScale = d3.scale.linear().domain([50, 200]).range([2, 8]),
        colorScale = d3.scale.category10();        
        
/*    var timeScale = d3.time.scale.utc()  // utc does't shift for daylight saving time
        .domain([Date.parse(new Date(2002, 0, 1)),
                 Date.parse(new Date(2003, 12, 2))])
        .range([0, timeSteps]);  
*/
 //  functions // 

    function type(d){
      d.sample = +d.sample;
      d.date = Date.parse(d.date);
      d.id = +d.id;
      d.section = +d.section;
      d.len = +d.len;
      d.enc = +d.enc;
      d.moveDir = +d.moveDir;
      d.distMoved = +d.distMoved;
      d.lagSection = +d.lagSection;
      return d;
    }

    function getData(d,s) {
      return d.filter( function(d){
        return d.sample == s;
      });
    }   
       
    // Absolute positions for the dots based on data
    function position(dot) {
      dot
        .attr("cx", function (d){ return xScale(d.len); })
        .attr("cy", function (d  ){ return yScale(y(d)); })
        .attr("r", function(d) { return radiusScale(d.len); });
    }

    // Relative positions for the dots based on data
    function position2(dot) {
      dot
        .attr("cx", function (d){ return xScale2(d.len); })
        .attr("cy", function (d  ){ return yScale2(y2(d)); })
        .attr("r", function(d) { return radiusScale(d.len); });
    }

    // Sort numbers ascending
    function compareNumbers(a, b) {
     return a - b;
    }

    // Update Individual absolute Locations
    function updateRenderAbs(inData) {

      // BIND DATA
      var circles = g1.selectAll("circle")
            .data(inData, keyID);

      // APPEND NEW CIRCLE for each data element that doesn't already have a circle
      circles.enter().append("circle")
          .style("fill",  "green") //function(d  ){ return colorScale( color(d) ); })
          .style("fill-opacity", 1e-6)
 //         .transition()
//            .delay(8000)
      ;

      // UPDATE the color/position/size of each circle that has a data element
      circles
        .transition()
          .duration(4000)
            .style("fill", "darkgrey")// function(d  ){ return colorScale( color(d) ); })
            .style("fill-opacity", 1)
            .call(position)
        ;

      // REMOVE any existing circles that no longer have data
      circles.exit()
          .style("fill", "red")
          .transition()
            .duration(3000)
       //     .attr ("cx",    500)
      //      .attr ("cy",    200)
            
            .style("fill-opacity", 1e-3)
       .remove();

    }

    // Update Individual relative Locations
    function updateRenderRel(inData) {

      // BIND DATA
      var circles2 = g2.selectAll("circle")
            .data(inData, keyID);
console.log(circles2);
      // APPEND NEW CIRCLE for each data element that doesn't already have a circle
      circles2.enter().append("circle")
          .style("fill",  "green") //function(d  ){ return colorScale( color(d) ); })
          .style("fill-opacity", 1e-6)
 //         .transition()
//            .delay(8000)
      ;

      // UPDATE the color/position/size of each circle that has a data element
      circles2
        .transition()
          .duration(4000)
            .style("fill", "darkgrey")// function(d  ){ return colorScale( color(d) ); })
            .style("fill-opacity", 1)
            .call(position2)
        ;

      // REMOVE any existing circles that no longer have data
      circles2.exit()
          .style("fill", "red")
          .transition()
            .duration(3000)
       //     .attr ("cx",    500)
      //      .attr ("cy",    200)
            
            .style("fill-opacity", 1e-3)
       .remove();

    }


 // run //

      d3.csv("coreDataOut.csv", type,  function (inData){  
       console.log(inData); 
        //Map sample num to array
        var samps = inData.map(function(d) { return d.sample; });
  //        var sampDays = inData.map(function(d) { return d.date; });

        //Construct set of samples
        var sampSet = [];
        samps.forEach(function(samp) { 
          if (sampSet.indexOf(samp) == -1) {
            sampSet.push(samp);
          }
        });
//console.log(samps);


        //Sort samples in ascending order
        sampSet.sort(compareNumbers)
//console.log(sampSet);
//console.log(samps);

        //Add slider to control samples
        d3.select("body")
          .append("input")
          .attr({type: "range", name: "Sample", min: sampSet[0], max: sampSet[sampSet.length - 1], value: sampSet[0]})
          .attr("id", "sampSlider")
          .property("title", "Sample: " + sampSet[sampSet.length - 1])
          .on("input", function() { 
            updateRenderAbs(getData(inData, Math.floor(this.value)));
            updateRenderRel(getData(inData, Math.floor(this.value)));
            this.title = "Sample: " + Math.floor(this.value);
          });


        //Position first sample
        updateRenderAbs(getData(inData,sampSet[0]));
        updateRenderRel(getData(inData,sampSet[0]));


        //Move through samples     
 /*       sampSet.forEach(function(samp, i) {
          if (i > 0) {
           setInterval(function(){
              updateRender(getData(inData, samp));
            }, 2000);
          };  
        });
*/
      });

      // JDW: if you look in the console, you'll see an error: "circles.exit"
      //      is not a function, because you've assigned the variable "circles"
      //      to the result of the enter().append() calls, so "circles" is a
      //      reference to all the circles added in this iteration
      //
      //      so that's why exit isn't working, because it doesn't exist as a
      //      method on "circles"
      //
      //      instead, "circles" should be assigned to the result of the data
      //      binding, then .enter() should be called in a separate statement

      // OLD CODE:
      // var circles = svg.selectAll("circles")
      //       .data(inData, keyID)
      //       .enter()
      //       .append("circle");

      // NEW CODE:
      // var circles = svg.selectAll("circles")
      //       .data(inData, keyID);
      // circles.enter()
      //       .append("circle");

      // JDW: but that still won't work because you're not doing the
      //      selection correctly
      //
      //      although selectAll("circles") sounds like it should work,
      //      what is "circles" referring to here?
      //
      //      what you pass to selectAll() is called a "selector" query,
      //      which is used in CSS. For example if something has class="fish",
      //      then you could select it with the selector query ".fish" because
      //      the "." means class. You can also use id's with "#",
      //      so <div id="fish"></div> could be selected with "#fish" query.
      //      Finally, you can select by tag name, which is what you want here.
      //      When you .append("circle"), that adds elements in the HTML
      //      (technically to the Document Object Model or DOM) named circle
      //      like this: <circle></circle>
      //
      //      so what you want is to selectAll("circle") which will select all
      //      elements of type "circle"
      //
      //      you were trying to select all elements of type "circles" which don't
      //      exist, so that selection always came back empty, and thus every time
      //      this was run, it would append more circles since the "circles"
      //      variable was an empty selection
      //
      //      anyway, this is what you want:
    </script>

  </body>
</html>


